# This file was automatically generated by gh-aw. DO NOT EDIT.
# To update this file, edit the corresponding .md file and run:
#   gh aw compile

name: "Label Pull Request Automatically"
on:
  pull_request:
    types:
    - opened
    - labeled
  workflow_dispatch: null

permissions: {}

concurrency:
  group: "gh-aw-${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}"
  cancel-in-progress: true

run-name: "Label Pull Request Automatically"

jobs:
  task:
    runs-on: ubuntu-latest
    permissions:
      actions: write  # Required for github.rest.actions.cancelWorkflowRun()
    steps:
      - name: Check team membership for workflow
        id: check-team-member
        uses: actions/github-script@v7
        env:
          GITHUB_AW_REQUIRED_ROLES: admin,maintainer
        with:
          script: |
            async function setCancelled(message) {
              try {
                await github.rest.actions.cancelWorkflowRun({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  run_id: context.runId,
                });
                core.info(`Cancellation requested for this workflow run: ${message}`);
              } catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                core.warning(`Failed to cancel workflow run: ${errorMessage}`);
                core.setFailed(message); // Fallback if API call fails
              }
            }
            async function main() {
              const { eventName } = context;
              // skip check for safe events
              const safeEvents = ["workflow_dispatch", "workflow_run", "schedule"];
              if (safeEvents.includes(eventName)) {
                core.info(`✅ Event ${eventName} does not require validation`);
                return;
              }
              const actor = context.actor;
              const { owner, repo } = context.repo;
              const requiredPermissionsEnv = process.env.GITHUB_AW_REQUIRED_ROLES;
              const requiredPermissions = requiredPermissionsEnv
                ? requiredPermissionsEnv.split(",").filter(p => p.trim() !== "")
                : [];
              if (!requiredPermissions || requiredPermissions.length === 0) {
                core.error(
                  "❌ Configuration error: Required permissions not specified. Contact repository administrator."
                );
                await setCancelled(
                  "Configuration error: Required permissions not specified"
                );
                return;
              }
              // Check if the actor has the required repository permissions
              try {
                core.debug(
                  `Checking if user '${actor}' has required permissions for ${owner}/${repo}`
                );
                core.debug(`Required permissions: ${requiredPermissions.join(", ")}`);
                const repoPermission =
                  await github.rest.repos.getCollaboratorPermissionLevel({
                    owner: owner,
                    repo: repo,
                    username: actor,
                  });
                const permission = repoPermission.data.permission;
                core.debug(`Repository permission level: ${permission}`);
                // Check if user has one of the required permission levels
                for (const requiredPerm of requiredPermissions) {
                  if (
                    permission === requiredPerm ||
                    (requiredPerm === "maintainer" && permission === "maintain")
                  ) {
                    core.info(`✅ User has ${permission} access to repository`);
                    return;
                  }
                }
                core.warning(
                  `User permission '${permission}' does not meet requirements: ${requiredPermissions.join(", ")}`
                );
              } catch (repoError) {
                const errorMessage =
                  repoError instanceof Error ? repoError.message : String(repoError);
                core.error(`Repository permission check failed: ${errorMessage}`);
                await setCancelled(`Repository permission check failed: ${errorMessage}`);
                return;
              }
              // Cancel the workflow when permission check fails
              core.warning(
                `❌ Access denied: Only authorized users can trigger this workflow. User '${actor}' is not authorized. Required permissions: ${requiredPermissions.join(", ")}`
              );
              await setCancelled(
                `Access denied: User '${actor}' is not authorized. Required permissions: ${requiredPermissions.join(", ")}`
              );
            }
            await main();

  label-pull-request-automatically:
    needs: task
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '24'
      - name: Install Codex
        run: npm install -g @openai/codex@0.34.0
      - name: Setup MCPs
        run: |
          mkdir -p /tmp/mcp-config
          cat > /tmp/mcp-config/config.toml << EOF
          [history]
          persistence = "none"
          
          [mcp_servers.github]
          user_agent = "label-pull-request-automatically"
          command = "docker"
          args = [
            "run",
            "-i",
            "--rm",
            "-e",
            "GITHUB_PERSONAL_ACCESS_TOKEN",
            "ghcr.io/github/github-mcp-server:sha-09deac4"
          ]
          env = { "GITHUB_PERSONAL_ACCESS_TOKEN" = "${{ secrets.GITHUB_TOKEN }}" }
          EOF
      - name: Create prompt
        env:
          GITHUB_AW_PROMPT: /tmp/aw-prompts/prompt.txt
        run: |
          mkdir -p /tmp/aw-prompts
          cat > $GITHUB_AW_PROMPT << 'EOF'
          Assign labels to the pull request #${{ github.event.pull_request.number }}.
          
          EOF
      - name: Print prompt to step summary
        run: |
          echo "## Generated Prompt" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo '``````markdown' >> $GITHUB_STEP_SUMMARY
          cat $GITHUB_AW_PROMPT >> $GITHUB_STEP_SUMMARY
          echo '``````' >> $GITHUB_STEP_SUMMARY
        env:
          GITHUB_AW_PROMPT: /tmp/aw-prompts/prompt.txt
      - name: Generate agentic run info
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            const awInfo = {
              engine_id: "codex",
              engine_name: "Codex",
              model: "openai/gpt-oss-120b:free",
              version: "0.34.0",
              workflow_name: "Label Pull Request Automatically",
              experimental: true,
              supports_tools_whitelist: true,
              supports_http_transport: false,
              run_id: context.runId,
              run_number: context.runNumber,
              run_attempt: process.env.GITHUB_RUN_ATTEMPT,
              repository: context.repo.owner + '/' + context.repo.repo,
              ref: context.ref,
              sha: context.sha,
              actor: context.actor,
              event_name: context.eventName,
              staged: false,
              created_at: new Date().toISOString()
            };
            
            // Write to /tmp directory to avoid inclusion in PR
            const tmpPath = '/tmp/aw_info.json';
            fs.writeFileSync(tmpPath, JSON.stringify(awInfo, null, 2));
            console.log('Generated aw_info.json at:', tmpPath);
            console.log(JSON.stringify(awInfo, null, 2));
      - name: Upload agentic run info
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: aw_info.json
          path: /tmp/aw_info.json
          if-no-files-found: warn
      - name: Run Codex
        run: |
          set -o pipefail
          INSTRUCTION=$(cat /tmp/aw-prompts/prompt.txt)
          export CODEX_HOME=/tmp/mcp-config
          
          # Create log directory outside git repo
          mkdir -p /tmp/aw-logs
          
          # Run codex with log capture - pipefail ensures codex exit code is preserved
          codex exec \
            -c model=openai/gpt-oss-120b:free --provider openrouter \
            --full-auto "$INSTRUCTION" 2>&1 | tee /tmp/label-pull-request-automatically.log
        env:
          DEBUG_MODE: true
          GITHUB_AW_PROMPT: /tmp/aw-prompts/prompt.txt
          GITHUB_STEP_SUMMARY: ${{ env.GITHUB_STEP_SUMMARY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          OPENAI_API_BASE: https://openrouter.ai/api/v1
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      - name: Parse agent logs for step summary
        if: always()
        uses: actions/github-script@v7
        env:
          GITHUB_AW_AGENT_OUTPUT: /tmp/label-pull-request-automatically.log
        with:
          script: |
            function main() {
              const fs = require("fs");
              try {
                const logFile = process.env.GITHUB_AW_AGENT_OUTPUT;
                if (!logFile) {
                  core.info("No agent log file specified");
                  return;
                }
                if (!fs.existsSync(logFile)) {
                  core.info(`Log file not found: ${logFile}`);
                  return;
                }
                const content = fs.readFileSync(logFile, "utf8");
                const parsedLog = parseCodexLog(content);
                if (parsedLog) {
                  core.summary.addRaw(parsedLog).write();
                  core.info("Codex log parsed successfully");
                } else {
                  core.error("Failed to parse Codex log");
                }
              } catch (error) {
                core.setFailed(error instanceof Error ? error : String(error));
              }
            }
            /**
             * Parse codex log content and format as markdown
             * @param {string} logContent - The raw log content to parse
             * @returns {string} Formatted markdown content
             */
            function parseCodexLog(logContent) {
              try {
                const lines = logContent.split("\n");
                let markdown = "## 🤖 Commands and Tools\n\n";
                const commandSummary = [];
                // First pass: collect commands for summary
                for (let i = 0; i < lines.length; i++) {
                  const line = lines[i];
                  // Detect tool usage and exec commands
                  if (line.includes("] tool ") && line.includes("(")) {
                    // Extract tool name
                    const toolMatch = line.match(/\] tool ([^(]+)\(/);
                    if (toolMatch) {
                      const toolName = toolMatch[1];
                      // Look ahead to find the result status
                      let statusIcon = "❓"; // Unknown by default
                      for (let j = i + 1; j < Math.min(i + 5, lines.length); j++) {
                        const nextLine = lines[j];
                        if (nextLine.includes("success in")) {
                          statusIcon = "✅";
                          break;
                        } else if (
                          nextLine.includes("failure in") ||
                          nextLine.includes("error in") ||
                          nextLine.includes("failed in")
                        ) {
                          statusIcon = "❌";
                          break;
                        }
                      }
                      if (toolName.includes(".")) {
                        // Format as provider::method
                        const parts = toolName.split(".");
                        const provider = parts[0];
                        const method = parts.slice(1).join("_");
                        commandSummary.push(
                          `* ${statusIcon} \`${provider}::${method}(...)\``
                        );
                      } else {
                        commandSummary.push(`* ${statusIcon} \`${toolName}(...)\``);
                      }
                    }
                  } else if (line.includes("] exec ")) {
                    // Extract exec command
                    const execMatch = line.match(/exec (.+?) in/);
                    if (execMatch) {
                      const formattedCommand = formatBashCommand(execMatch[1]);
                      // Look ahead to find the result status
                      let statusIcon = "❓"; // Unknown by default
                      for (let j = i + 1; j < Math.min(i + 5, lines.length); j++) {
                        const nextLine = lines[j];
                        if (nextLine.includes("succeeded in")) {
                          statusIcon = "✅";
                          break;
                        } else if (
                          nextLine.includes("failed in") ||
                          nextLine.includes("error")
                        ) {
                          statusIcon = "❌";
                          break;
                        }
                      }
                      commandSummary.push(`* ${statusIcon} \`${formattedCommand}\``);
                    }
                  }
                }
                // Add command summary
                if (commandSummary.length > 0) {
                  for (const cmd of commandSummary) {
                    markdown += `${cmd}\n`;
                  }
                } else {
                  markdown += "No commands or tools used.\n";
                }
                // Add Information section
                markdown += "\n## 📊 Information\n\n";
                // Extract metadata from Codex logs
                let totalTokens = 0;
                const tokenMatches = logContent.match(/tokens used: (\d+)/g);
                if (tokenMatches) {
                  for (const match of tokenMatches) {
                    const numberMatch = match.match(/(\d+)/);
                    if (numberMatch) {
                      const tokens = parseInt(numberMatch[1]);
                      totalTokens += tokens;
                    }
                  }
                }
                if (totalTokens > 0) {
                  markdown += `**Total Tokens Used:** ${totalTokens.toLocaleString()}\n\n`;
                }
                // Count tool calls and exec commands
                const toolCalls = (logContent.match(/\] tool /g) || []).length;
                const execCommands = (logContent.match(/\] exec /g) || []).length;
                if (toolCalls > 0) {
                  markdown += `**Tool Calls:** ${toolCalls}\n\n`;
                }
                if (execCommands > 0) {
                  markdown += `**Commands Executed:** ${execCommands}\n\n`;
                }
                markdown += "\n## 🤖 Reasoning\n\n";
                // Second pass: process full conversation flow with interleaved reasoning, tools, and commands
                let inThinkingSection = false;
                for (let i = 0; i < lines.length; i++) {
                  const line = lines[i];
                  // Skip metadata lines
                  if (
                    line.includes("OpenAI Codex") ||
                    line.startsWith("--------") ||
                    line.includes("workdir:") ||
                    line.includes("model:") ||
                    line.includes("provider:") ||
                    line.includes("approval:") ||
                    line.includes("sandbox:") ||
                    line.includes("reasoning effort:") ||
                    line.includes("reasoning summaries:") ||
                    line.includes("tokens used:")
                  ) {
                    continue;
                  }
                  // Process thinking sections
                  if (line.includes("] thinking")) {
                    inThinkingSection = true;
                    continue;
                  }
                  // Process tool calls
                  if (line.includes("] tool ") && line.includes("(")) {
                    inThinkingSection = false;
                    const toolMatch = line.match(/\] tool ([^(]+)\(/);
                    if (toolMatch) {
                      const toolName = toolMatch[1];
                      // Look ahead to find the result status
                      let statusIcon = "❓"; // Unknown by default
                      for (let j = i + 1; j < Math.min(i + 5, lines.length); j++) {
                        const nextLine = lines[j];
                        if (nextLine.includes("success in")) {
                          statusIcon = "✅";
                          break;
                        } else if (
                          nextLine.includes("failure in") ||
                          nextLine.includes("error in") ||
                          nextLine.includes("failed in")
                        ) {
                          statusIcon = "❌";
                          break;
                        }
                      }
                      if (toolName.includes(".")) {
                        const parts = toolName.split(".");
                        const provider = parts[0];
                        const method = parts.slice(1).join("_");
                        markdown += `${statusIcon} ${provider}::${method}(...)\n\n`;
                      } else {
                        markdown += `${statusIcon} ${toolName}(...)\n\n`;
                      }
                    }
                    continue;
                  }
                  // Process exec commands
                  if (line.includes("] exec ")) {
                    inThinkingSection = false;
                    const execMatch = line.match(/exec (.+?) in/);
                    if (execMatch) {
                      const formattedCommand = formatBashCommand(execMatch[1]);
                      // Look ahead to find the result status
                      let statusIcon = "❓"; // Unknown by default
                      for (let j = i + 1; j < Math.min(i + 5, lines.length); j++) {
                        const nextLine = lines[j];
                        if (nextLine.includes("succeeded in")) {
                          statusIcon = "✅";
                          break;
                        } else if (
                          nextLine.includes("failed in") ||
                          nextLine.includes("error")
                        ) {
                          statusIcon = "❌";
                          break;
                        }
                      }
                      markdown += `${statusIcon} \`${formattedCommand}\`\n\n`;
                    }
                    continue;
                  }
                  // Process thinking content
                  if (
                    inThinkingSection &&
                    line.trim().length > 20 &&
                    !line.startsWith("[2025-")
                  ) {
                    const trimmed = line.trim();
                    // Add thinking content directly
                    markdown += `${trimmed}\n\n`;
                  }
                }
                return markdown;
              } catch (error) {
                core.error(`Error parsing Codex log: ${error}`);
                return "## 🤖 Commands and Tools\n\nError parsing log content.\n\n## 🤖 Reasoning\n\nUnable to parse reasoning from log.\n\n";
              }
            }
            /**
             * Format bash command for display
             * @param {string} command - The command to format
             * @returns {string} Formatted command string
             */
            function formatBashCommand(command) {
              if (!command) return "";
              // Convert multi-line commands to single line by replacing newlines with spaces
              // and collapsing multiple spaces
              let formatted = command
                .replace(/\n/g, " ") // Replace newlines with spaces
                .replace(/\r/g, " ") // Replace carriage returns with spaces
                .replace(/\t/g, " ") // Replace tabs with spaces
                .replace(/\s+/g, " ") // Collapse multiple spaces into one
                .trim(); // Remove leading/trailing whitespace
              // Escape backticks to prevent markdown issues
              formatted = formatted.replace(/`/g, "\\`");
              // Truncate if too long (keep reasonable length for summary)
              const maxLength = 80;
              if (formatted.length > maxLength) {
                formatted = formatted.substring(0, maxLength) + "...";
              }
              return formatted;
            }
            /**
             * Truncate string to maximum length
             * @param {string} str - The string to truncate
             * @param {number} maxLength - Maximum length allowed
             * @returns {string} Truncated string
             */
            function truncateString(str, maxLength) {
              if (!str) return "";
              if (str.length <= maxLength) return str;
              return str.substring(0, maxLength) + "...";
            }
            // Export for testing
            if (typeof module !== "undefined" && module.exports) {
              module.exports = { parseCodexLog, formatBashCommand, truncateString };
            }
            main();
      - name: Upload agent logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: label-pull-request-automatically.log
          path: /tmp/label-pull-request-automatically.log
          if-no-files-found: warn
      - name: Validate agent logs for errors
        if: always()
        uses: actions/github-script@v7
        env:
          GITHUB_AW_AGENT_OUTPUT: /tmp/label-pull-request-automatically.log
          GITHUB_AW_ERROR_PATTERNS: "[{\"pattern\":\"\\\\[(\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2})\\\\]\\\\s+stream\\\\s+(error):\\\\s+(.+)\",\"level_group\":2,\"message_group\":3,\"description\":\"Codex stream errors with timestamp\"},{\"pattern\":\"\\\\[(\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2})\\\\]\\\\s+(ERROR):\\\\s+(.+)\",\"level_group\":2,\"message_group\":3,\"description\":\"Codex ERROR messages with timestamp\"},{\"pattern\":\"\\\\[(\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2})\\\\]\\\\s+(WARN|WARNING):\\\\s+(.+)\",\"level_group\":2,\"message_group\":3,\"description\":\"Codex warning messages with timestamp\"}]"
        with:
          script: |
            function main() {
              const fs = require("fs");
              try {
                const logFile = process.env.GITHUB_AW_AGENT_OUTPUT;
                if (!logFile) {
                  throw new Error(
                    "GITHUB_AW_AGENT_OUTPUT environment variable is required"
                  );
                }
                if (!fs.existsSync(logFile)) {
                  throw new Error(`Log file not found: ${logFile}`);
                }
                // Get error patterns from environment variables
                const patterns = getErrorPatternsFromEnv();
                if (patterns.length === 0) {
                  throw new Error(
                    "GITHUB_AW_ERROR_PATTERNS environment variable is required and must contain at least one pattern"
                  );
                }
                const content = fs.readFileSync(logFile, "utf8");
                const hasErrors = validateErrors(content, patterns);
                if (hasErrors) {
                  core.setFailed("Errors detected in agent logs - failing workflow step");
                } else {
                  core.info("Error validation completed successfully");
                }
              } catch (error) {
                console.debug(error);
                core.setFailed(
                  `Error validating log: ${error instanceof Error ? error.message : String(error)}`
                );
              }
            }
            function getErrorPatternsFromEnv() {
              const patternsEnv = process.env.GITHUB_AW_ERROR_PATTERNS;
              if (!patternsEnv) {
                throw new Error(
                  "GITHUB_AW_ERROR_PATTERNS environment variable is required"
                );
              }
              try {
                const patterns = JSON.parse(patternsEnv);
                if (!Array.isArray(patterns)) {
                  throw new Error("GITHUB_AW_ERROR_PATTERNS must be a JSON array");
                }
                return patterns;
              } catch (e) {
                throw new Error(
                  `Failed to parse GITHUB_AW_ERROR_PATTERNS as JSON: ${e instanceof Error ? e.message : String(e)}`
                );
              }
            }
            /**
             * @param {string} logContent
             * @param {any[]} patterns
             * @returns {boolean}
             */
            function validateErrors(logContent, patterns) {
              const lines = logContent.split("\n");
              let hasErrors = false;
              for (const pattern of patterns) {
                const regex = new RegExp(pattern.pattern, "g");
                for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
                  const line = lines[lineIndex];
                  let match;
                  while ((match = regex.exec(line)) !== null) {
                    const level = extractLevel(match, pattern);
                    const message = extractMessage(match, pattern, line);
                    const errorMessage = `Line ${lineIndex + 1}: ${message} (Pattern: ${pattern.description || "Unknown pattern"}, Raw log: ${truncateString(line.trim(), 120)})`;
                    if (level.toLowerCase() === "error") {
                      core.error(errorMessage);
                      hasErrors = true;
                    } else {
                      core.warning(errorMessage);
                    }
                  }
                }
              }
              return hasErrors;
            }
            /**
             * @param {any} match
             * @param {any} pattern
             * @returns {string}
             */
            function extractLevel(match, pattern) {
              if (
                pattern.level_group &&
                pattern.level_group > 0 &&
                match[pattern.level_group]
              ) {
                return match[pattern.level_group];
              }
              // Try to infer level from the match content
              const fullMatch = match[0];
              if (fullMatch.toLowerCase().includes("error")) {
                return "error";
              } else if (fullMatch.toLowerCase().includes("warn")) {
                return "warning";
              }
              return "unknown";
            }
            /**
             * @param {any} match
             * @param {any} pattern
             * @param {any} fullLine
             * @returns {string}
             */
            function extractMessage(match, pattern, fullLine) {
              if (
                pattern.message_group &&
                pattern.message_group > 0 &&
                match[pattern.message_group]
              ) {
                return match[pattern.message_group].trim();
              }
              // Fallback to the full match or line
              return match[0] || fullLine.trim();
            }
            /**
             * @param {any} str
             * @param {any} maxLength
             * @returns {string}
             */
            function truncateString(str, maxLength) {
              if (!str) return "";
              if (str.length <= maxLength) return str;
              return str.substring(0, maxLength) + "...";
            }
            // Export for testing
            if (typeof module !== "undefined" && module.exports) {
              module.exports = {
                validateErrors,
                extractLevel,
                extractMessage,
                getErrorPatternsFromEnv,
                truncateString,
              };
            }
            // Only run main if this script is executed directly, not when imported for testing
            if (require.main === module) {
              main();
            }

